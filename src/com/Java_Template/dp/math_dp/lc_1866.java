package com.Java_Template.dp.math_dp;

// https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/
class lc_1866 { // 第一类斯特林数
    private final static long[][] dp = new long[1001][1001]; // dp[i][j]表示长度为i的排列分成j份非空圆排列的方案数
    // 将这n根木棍分成k份，单独讨论k份，对于每一份（假设当前这一份有m根木棍），只要将最高的木棍放在最前面，后面的任意放，（m - 1）!种放法。即为一个长为 m 的圆排列的方案数。
    // 因此原问题本质上就是在问长为 n 的排列划分成 k 个非空圆排列的方案数，这就是第一类斯特林数。
    // 圆排列：https://blog.csdn.net/destiny_balabala/article/details/108875315
    private final static long Mod = (long) 1e9 + 7;
    static {
        dp[0][0] = 1; 
        for (int i = 1; i <= 1000; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i][j] = (dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j]) % Mod;
            }
        }
    }

    public int rearrangeSticks(int n, int k) {
        return (int) dp[n][k];
    }
    
    // n个人坐k张桌子，不区分桌子，只区分人如何坐的；
    // dp[i][j]表示i个人坐j个桌子的方案数；
    // 首先第i个人单独坐一个桌子，那么前i - 1个人坐j - 1张桌子dp[i - 1][j - 1]；
    // 然后第i个人和别人一起坐，有前i - 1个人坐j张桌子dp[i - 1][j]，然后坐在i- 1个人的左边，有dp[i - 1][j]*(i - 1)种方案；
    // 总方案数：dp[i][j] = dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j]
    

    // 这个递推式基于组合数学中的「**第一类斯特林数**」的定义，它描述的是如何将 `n` 个不同的物体划分成 `k` 个**非空**的圆排列的方式数。为了理解这个递推式，我们可以逐步分析问题：
    //
    //### 1. 问题理解：
    //- 你有 `n` 根木棍，想要将它们划分成 `k` 份，并且每一份是一个**非空圆排列**。
    //- **圆排列**的特殊之处在于它们不区分旋转，即将最高的木棍固定在第一个位置，其他的木棍可以任意排列。
    //
    //### 2. 递推式推导：
    //
    //**`dp[i][j]` 的含义**：
    //长度为 `i` 的排列分成 `j` 个非空圆排列的方案数。
    //
    //#### 递推式的两部分：
    //
    //`dp[i][j] = dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j]`
    //
    //- **第一部分 `dp[i - 1][j - 1]`：**
    //    - 这是当我们将 `i` 个物体中的一个单独作为新的圆排列，剩下的 `i - 1` 个物体要划分成 `j - 1` 份圆排列。这表示「新的一份」圆排列是单独构成的（比如可以把第 `i` 个物体作为一个新的单独圆排列）。
    //
    //- **第二部分 `(i - 1) * dp[i - 1][j]`：**
    //    - 这是当我们将第 `i` 个物体加入到已经划分好的 `j` 份圆排列中的任意一个中。因为每个圆排列本质上是一个循环，所以第 `i` 个物体有 `i - 1` 个位置可以插入到其中。
    //
    //#### 小结：
    //- 递推式反映了两种情况：要么第 `i` 个物体单独作为新的圆排列，要么它插入到已有的圆排列中。
}