# 概率期望

1227\. 飞机座位分配概率
---------------

有 `n` 位乘客即将登机，飞机正好有 `n` 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。

剩下的乘客将会：

*   如果他们自己的座位还空着，就坐到自己的座位上，

*   当他们自己的座位被占用时，随机选择其他座位

第 `n` 位乘客坐在自己的座位上的概率是多少？

**示例 1：**

**输入：**n = 1
**输出：**1.00000
**解释：**第一个人只会坐在自己的位置上。

**示例 2：**

**输入:** n = 2
**输出:** 0.50000
**解释：**在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。

**提示：**

*   `1 <= n <= 10^5`

[https://leetcode.cn/problems/airplane-seat-assignment-probability/description/](https://leetcode.cn/problems/airplane-seat-assignment-probability/description/)

```java
class Solution {
    public double nthPersonGetsNthSeat(int n) {
        return n == 1 ? 1.0 : 0.5;
    }
}
```

688\. 骑士在棋盘上的概率
---------------

在一个 `n x n` 的国际象棋棋盘上，一个骑士从单元格 `(row, column)` 开始，并尝试进行 `k` 次移动。行和列是 **从 0 开始** 的，所以左上单元格是 `(0,0)` ，右下单元格是 `(n - 1, n - 1)` 。

象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png)

每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。

骑士继续移动，直到它走了 `k` 步或离开了棋盘。

返回 _骑士在棋盘停止移动后仍留在棋盘上的概率_ 。

**示例 1：**

**输入:** n = 3, k = 2, row = 0, column = 0
**输出:** 0.0625
**解释:** 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。
在每一个位置上，也有两种移动可以让骑士留在棋盘上。
骑士留在棋盘上的总概率是0.0625。

**示例 2：**

**输入:** n = 1, k = 0, row = 0, column = 0
**输出:** 1.00000

**提示:**

*   `1 <= n <= 25`
*   `0 <= k <= 100`
*   `0 <= row, column <= n - 1`

[https://leetcode.cn/problems/knight-probability-in-chessboard/description/](https://leetcode.cn/problems/knight-probability-in-chessboard/description/)

```java
class Solution {
    static int[][] dirs = {{-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}};

    public double knightProbability(int n, int k, int row, int column) {
        double[][][] dp = new double[k + 1][n][n];
        dp[0][row][column] = 1.0;
        for (int m = 0; m < k; m++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    for (int[] dir : dirs) {
                        int newRow = i + dir[0], newColumn = j + dir[1];
                        if (newRow >= 0 && newRow < n && newColumn >= 0 && newColumn < n) {
                            dp[m + 1][newRow][newColumn] += dp[m][i][j] / 8;
                        }
                    }
                }
            }
        }
        double total = 0.0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                total += dp[k][i][j];
            }
        }
        return total;
    }
}
```

837\. 新 21 点
------------

爱丽丝参与一个大致基于纸牌游戏 **“21点”** 规则的游戏，描述如下：

爱丽丝以 `0` 分开始，并在她的得分少于 `k` 分时抽取数字。 抽取时，她从 `[1, maxPts]` 的范围中随机获得一个整数作为分数进行累计，其中 `maxPts` 是一个整数。 每次抽取都是独立的，其结果具有相同的概率。

当爱丽丝获得 `k` 分 **或更多分** 时，她就停止抽取数字。

爱丽丝的分数不超过 `n` 的概率是多少？

与实际答案误差不超过 `10-5` 的答案将被视为正确答案。

 

**示例 1：**

**输入：**n = 10, k = 1, maxPts = 10
**输出：**1.00000
**解释：**爱丽丝得到一张牌，然后停止。

**示例 2：**

**输入：**n = 6, k = 1, maxPts = 10
**输出：**0.60000
**解释：**爱丽丝得到一张牌，然后停止。 在 10 种可能性中的 6 种情况下，她的得分不超过 6 分。

**示例 3：**

**输入：**n = 21, k = 17, maxPts = 10
**输出：**0.73278

**提示：**

*   `0 <= k <= n <= 104`
*   `1 <= maxPts <= 104`

[https://leetcode.cn/problems/new-21-game/description/](https://leetcode.cn/problems/new-21-game/description/)

```java

```

1467\. 两个盒子中球的颜色数相同的概率
----------------------

桌面上有 `2n` 个颜色不完全相同的球，球上的颜色共有 `k` 种。给你一个大小为 `k` 的整数数组 `balls` ，其中 `balls[i]` 是颜色为 `i` 的球的数量。

所有的球都已经 **随机打乱顺序** ，前 `n` 个球放入第一个盒子，后 `n` 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。

**注意：**这两个盒子是不同的。例如，两个球颜色分别为 `a` 和 `b`，盒子分别为 `[]` 和 `()`，那么 `[a] (b)` 和 `[b] (a)` 这两种分配方式是不同的（请认真阅读示例的解释部分）。

请返回「两个盒子中球的颜色数相同」的情况的概率。答案与真实值误差在 `10^-5` 以内，则被视为正确答案

**示例 1：**

**输入：**balls = \[1,1\]
**输出：**1.00000
**解释：**球平均分配的方式只有两种：
- 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子
- 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子
  这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。

**示例 2：**

**输入：**balls = \[2,1,1\]
**输出：**0.66667
**解释：**球的列表为 \[1, 1, 2, 3\]
随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ：
\[1,1 / 2,3\], \[1,1 / 3,2\], \[1,2 / 1,3\], \[1,2 / 3,1\], \[1,3 / 1,2\], \[1,3 / 2,1\], \[2,1 / 1,3\], \[2,1 / 3,1\], \[2,3 / 1,1\], \[3,1 / 1,2\], \[3,1 / 2,1\], \[3,2 / 1,1\]
然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。
这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。
概率 = 8/12 = 0.66667

**示例 3：**

**输入：**balls = \[1,2,1,2\]
**输出：**0.60000
**解释：**球的列表为 \[1, 2, 2, 3, 4, 4\]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。
概率 = 108 / 180 = 0.6 。

**提示：**

*   `1 <= balls.length <= 8`
*   `1 <= balls[i] <= 6`
*   `sum(balls)` 是偶数

[https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/description/](https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/description/)

```java

```

808\. 分汤
--------

有 **A 和 B 两种类型** 的汤。一开始每种类型的汤有 `n` 毫升。有四种分配操作：

1.  提供 `100ml` 的 **汤A** 和 `0ml` 的 **汤B** 。
2.  提供 `75ml` 的 **汤A** 和 `25ml` 的 **汤B** 。
3.  提供 `50ml` 的 **汤A** 和 `50ml` 的 **汤B** 。
4.  提供 `25ml` 的 **汤A** 和 `75ml` 的 **汤B** 。

当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 `0.25` 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。

**注意** 不存在先分配 `100` ml **汤B** 的操作。

需要返回的值： **汤A** 先分配完的概率 +  **汤A和汤B** 同时分配完的概率 / 2。返回值在正确答案 `10-5` 的范围内将被认为是正确的。

**示例 1:**

**输入:** n = 50
**输出:** 0.62500
**解释:**如果我们选择前两个操作**，**A 首先将变为空。
对于第三个操作，A 和 B 会同时变为空。
对于第四个操作，B 首先将变为空。
所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 \*(1 + 1 + 0.5 + 0)= 0.625。

**示例 2:**

**输入:** n = 100
**输出:** 0.71875

**提示:**

*   `0 <= n <= 109`​​​​​​​

[https://leetcode.cn/problems/soup-servings/description/](https://leetcode.cn/problems/soup-servings/description/)

```java

```



LCR 185. 统计结果概率
---------------

你选择掷出 `num` 个色子，请返回所有点数总和的概率。

你需要用一个浮点数数组返回答案，其中第 `i` 个元素代表这 `num` 个骰子所能掷出的点数集合中第 `i` 小的那个的概率。

**示例 1：**

**输入：**num = 3
**输出：**\[0.00463,0.01389,0.02778,0.04630,0.06944,0.09722,0.11574,0.12500,0.12500,0.11574,0.09722,0.06944,0.04630,0.02778,0.01389,0.00463\]

**示例 2：**

**输入：**num = 5
**输出:**\[0.00013,0.00064,0.00193,0.00450,0.00900,0.01620,0.02636,0.03922,0.05401,0.06944,0.08372,0.09452,0.10031,0.10031,0.09452,0.08372,0.06944,0.05401,0.03922,0.02636,0.01620,0.00900,0.00450,0.00193,0.00064,0.00013\]

**提示：**

*   `1 <= num <= 11`

[https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/description/](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/description/)

```java

```



LCP 11. 期望个数统计
--------------

某互联网公司一年一度的春招开始了，一共有 `n` 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。

小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中**等可能**地取一个。现在给定 `n` 名面试者的能力值 `scores`，设 `X` 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 `X` 的期望。

提示：离散的非负随机变量的期望计算公式为 ![1](https://pic.leetcode.cn/1694957445-AweiqF-svg.svg)。在本题中，由于 `X` 的取值为 0 到 `n` 之间，期望计算公式可以是 ![2](https://pic.leetcode.cn/1694957449-DuBtfQ-svg1.svg)。

**示例 1：**

> 输入：`scores = [1,2,3]`
>
> 输出：`3`
>
> 解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。`X`的期望是 3 。

**示例 2：**

> 输入：`scores = [1,1]`
>
> 输出：`1`
>
> 解释：设两位面试者的编号为 0, 1。由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 `[[0,1],[1,0]]` 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 `[0,1]` 或者 `[1,0]` ，那么出现在同一位置的简历数为 2 ，否则是 0 。所以 `X` 的期望是 (2+0+2+0) \* 1/4 = 1

**示例 3：**

> 输入：`scores = [1,1,2]`
>
> 输出：`2`

**限制：**

*   `1 <= scores.length <= 10^5`
*   `0 <= scores[i] <= 10^6`

[https://leetcode.cn/problems/qi-wang-ge-shu-tong-ji/description/](https://leetcode.cn/problems/qi-wang-ge-shu-tong-ji/description/)

```java

```

