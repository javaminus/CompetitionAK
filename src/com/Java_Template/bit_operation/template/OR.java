package com.Java_Template.bit_operation.template;

import java.util.ArrayList;

/**
 * 按位或模板
 * 该模板可以做到
 *
 * 1. 求出所有子数组的按位或的结果，以及值等于该结果的子数组的个数。
 * 2. 求按位或结果等于任意给定数字的子数组的最短长度/最长长度。
 */
public class OR {
    public int[] smallestSubarrays(int[] nums) {

        // 按位或的性质：
        // (1) 以nums[i]为开头的按位或，最多有32种不同的结果（从0开始，变32步，变成11...1111
        // (2) 以nums[i]为开头的按位或，相同的数值形成的右端点为一段连续的区间
        //
        //     比如我们考虑下述从0001开始的按位或
        //     [1000] 0001 0011 0010 1001 1011
        //            0001|0011 0011|1011 1011
        //
        // 所以：记录相同的按位或的：最左 <右端点>，即可表示出这组按位或的结果。且需要记录的个数不会超过32个。
        //            (0001, 1) (0011, 2) (1011, 4)
        //
        // 这时，假设前面加入一个新元素1000，再求按位或：
        //     [1000] 0001 0011 0010 1001 1011
        //
        // 只需要和上述元组求按位或，再合并相同数值即可(合并相同数值去重，从而可保证每次循环需要计算的元素不超过32个)
        //    即 1000 和 (0000, 0) (0001, 1) (0011, 2) (1011, 4) 求按位或
        //               (1000, 0) (1001, 1) (1011, 2) (1011, 4)
        //    合并重复项：(1000, 0) (1001, 1) (1011, 2)

        int n = nums.length;
        int[] ans = new int[n];

        // 该ArrayList动态数组用于记录相同按位或的最左<右端点>，相当于(0001, 1) (0011, 2) (1011, 4)
        ArrayList<int[]> ors = new ArrayList<>();

        // 从后向前遍历，相当于加入新元素1000的过程
        for (int i = n - 1; i >= 0; i--) {

            // 加入元素0，从而在下面遍历元组的过程中可以求得nums[i]自身的按位或，相当于上述例子中的(0000, 0)
            ors.add(0, new int[]{0, i}); // 头插

            // 遍历动态数组，计算按位或、合并相同值
            // k, 记录本次遍历时，不同按位或的个数。可以理解成【删除有序数组中的重复项】中的左指针
            int k = 0;
            for (int[] or: ors) {
                or[0] |= nums[i];

                // or是第一个加入的元素，或者和上一个元组的按位或结果不同
                if (k == 0 || ors.get(k - 1)[0] != or[0]) {
                    // 原地更新，计数增加
                    ors.set(k++, or);
                }
            }

            // 遍历完毕，不同按位或的个数有k个，只保留这k个元素即可
            // 去除ArrayList中这k个元素后的其他元素，保证ArrayList中需要遍历的元组为常数个
            ors.subList(k, ors.size()).clear();

            // 记录答案，最大按位或的最左<右端点> - i + 1
            ans[i] = ors.get(ors.size() - 1)[1] - i + 1;
        }

        return ans;

    }
}
